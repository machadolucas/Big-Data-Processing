Place your Python code into a file named **collfilter.py**. Also return a text file **collfilter.txt**, as specified below.

[Collaborative filtering](https://en.wikipedia.org/wiki/Collaborative_filtering) is a basic tool in [recommendation systems](https://en.wikipedia.org/wiki/Recommender_system). The task is to try to predict what kind of novel items might be interesting to a user based on the user's own and other users' prior preferences. A typical example is an online video rental store (such as Netflix) that tries to guess what kind of movies to recommend to a user based on knowledge about what movies Netflix user has watched (or liked/disliked) before. This type of information is usually collected from a customer database (who rented what) and by allowing the users to give ratings to the movies they have watched.

In this question we deal with a simple form of user data, derived from [Last.fm](https://www.last.fm/) internet radio user in Germany.  The data is originally [from this page](http://www.salemmarafi.com/code/collaborative-filtering-r/) that discusses basic collaborative filtering with the R language. [This another page](http://www.salemmarafi.com/code/collaborative-filtering-with-python/) is a Python version of the preceding article. The latter article also contains example Python code, which however does not work with current Python libraries and would anyway run very slowly. But the basic ideas presented in the article are ok, so it is worth browsing through (including the code, but perhaps you should not imitate the code as such; just look at the high-level structure and ideas).

The Last.fm data describes which users has listened to which artists, and the information could then be used e.g. in order to recommend to users which new artists (= artists the user has not yet listened to) they also might like. The data is in CSV format and is basically a matrix whose columns correspond to artists and rows to users, and the values within the table are either 1 or 0, depending on whether the corresponding user has listened (= 1) or not (=0) to the corresponding artist. We do not care about user identities, so we can just use the convention that row **i** corresponds to user **i**. The columns are labeled with artist names (in lowercase). If you read the data into a Pandas dataframe **data**, then the value **data['michael jackson'][i]** is 1 if and only if user **i** has listened to Michael Jackson (so otherwise it is 0).

In the following we will use the term "like" to generally mean that a user has liked or listened or purchased, and so on, some item. We also assume that the data is stored in a Pandas dataframe **data** where rows correspond to users and columns to items, and that **distance** is some function that returns a distance value between two vectors of same length. We interpret similarity using distance: the smaller the distance, the more similar two vectors are.

So-called ["memory based"](https://en.wikipedia.org/wiki/Collaborative_filtering#Memory-based) collaborative filtering methods fall into two high-level categories: (1) item based and (2) user based. The item based approach looks at what kind of items the user has liked in the past, and will try to recommend similar items. The estimate about similarity of items is calculated based on user data: the more similar the sets of users that have liked an item are, the more similar the items are. That is, the similarity of two artists **x** and **y** is based on computing the similarity of their corresponding column vectors. For example **distance(data['michael jackson'], data['queen'])** would give the similarity between the artists Michael Jackson and Queen.

The user based approach tries to find other users with similar preferences as the current user, and will then recommend new items that these other users have liked in the past. The similarity of users is based on the set of items they have liked: the more similar the sets of liked items are, the more similar the corresponding users are. This is symmetric with the case of item based similarity: the similarity between users **i** and **j** is computed as the similarity between rows **i** and **j**, that is, as **distance(data.iloc[i], data.iloc[j])**.

### The task

In this task you do not need to implement a full collaborative filtering method. It is enough to do the following three tasks. We assume that there are **n** artists and **m** users.

1.  Compute an **n**-by-**n** table **artdists** whose value **artdists[x, y]** contains the distance between artists in columns **x** and **y** (where **x** and **y** are numeric column indices). Use [cosine distance](https://en.wikipedia.org/wiki/Cosine_similarity) as the distance function.

    *   This step is very straight-forward with the scipy library: simply call **squareform(pdist(data.T, "cosine"))**.
    *   Notes:
        *   **pdist** computes distances between all pairs of row vectors. As artist vectors are in columns, we give the transposed (rows become columns and vice versa) table **data.T** as the first parameter.
        *   **pdist** has built-in support for some basic distance functions (such as cosine distance, hence the parameter "cosine").
        *   **pdist** returns a compacted array. Calling **squareform** turns the result into a full matrix.
        *   The result of **squareform** is a [numpy ndarray](https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html). This table type has some differences to Pandas dataframes. E.g. the indexing style **artdists[x, y]** works with ndarrays (not with dataframes) and returns the value on row **x** and column **y**.
    *   See the documentations of [pdist](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html) and [squareform](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.squareform.html) for further details.
    *   Print into the file colfilter.txt a line that tells which two artists are most similar with each other. This should be in the form **distance;artistA;artistB**, where distance is the corresponding cosine distance and **artistA** and **artistB** the artist names. The values are separated by semicolons. Naturally you should exclude self-comparison: **artistA** must be different than **artistB**.
2.  Compute an **m**-by-**m** table **usrdists** whose value **usrdists[i, j]** contains the distance between users **i** and **j**. Use cosine distance as the distance function.
    *   Again a simple one-liner using **pdist**. Just note that now transposing **data** is not needed as we want to compare rows agains each other.
    *   Print into the file colfilter.txt a line that tells which two users are most similar with each other. This should be in the form **distance;i;j**, where distance is the corresponding cosine distance and **i** and **j** the user row indices. The values are separated by semicolons. Again exclude self-comparison: **i** must be different than **j**.
3.  Compute and print into the file collfilter.txt the corresponding cosine distances and names of those 10 artists that are most similar to Michael Jackson (based on the distances computed in step 1). Naturally Michael Jackson himself should not be counted into these 10 artists.
    *   Print each artist on a separate line in the form **distance artist**. That is, first the distance between that artist and Michael jackson, then a space, and then the artist name.